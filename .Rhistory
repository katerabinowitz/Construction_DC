## Combine the first two
combined <- makeCodeTree(trees[[1]], trees[[2]])
insert(combined, trees[-(1:2)])
}
}
createCodeTree <- function(trees) {
## 4d. Complete the function....
## return a singleton tree
while(length(trees) != 1) {
trees <- combine(trees)
}
trees
}
helloLeafList <- lapply(names(helloFreq), makeLeaf,weight=helloFreq)
helloLeadList
helloLeafList
helloFreq2<-unname(helloFreq)
helloFreq2
helloLeafList <- lapply(names(helloFreq), makeLeaf,weight=helloFreq2)
helloLeafList <- lapply(helloFreq, function makeLeaf (helloFreq))
helloLeafList <- lapply(helloFreq, function (makeLeaf) (helloFreq))
helloLeafList
helloLeafList <- lapply(seq_along(helloFreq), makeLeaf)
helloLeafList <- lapply(seq_along(helloFreq), makeLeaf(helloFreq))
helloLeafList <- lapply(seq_along(helloFreq), function(makeLeaf)(helloFreq))
helloLeafList
helloFreq <- sort(table(helloWorld),decreasing=T)
helloFreq
names(helloFreq)
makeLeaf(names(helloFreq),unname(helloFreq))
lapply(helloFreq,function(makeLeaf)(names(helloFreq),unname(helloFreq)))
lapply(helloFreq,function(makeLeaf)(names(helloFreq),weight=unname(helloFreq)))
lapply(helloFreq,function(makeLeaf)(names(helloFreq)),weight=unname(helloFreq)))
lapply(helloFreq,function(makeLeaf)(names(helloFreq)),weight=unname(helloFreq))
a<-read.csv("https://raw.githubusercontent.com/codefordc/school-modernization/master/InputData/Last%20Major%20Construction-Table%201.csv",
stringsAsFactors=FALSE, strip.white=TRUE)[c(2:4)]
b<-read.csv("https://raw.githubusercontent.com/codefordc/school-modernization/master/InputData/Last%20Major%20Construction-Table%201.csv",
stringsAsFactors=FALSE, strip.white=TRUE)[c(2:4)]
e<-read.csv("https://raw.githubusercontent.com/codefordc/school-modernization/master/InputData/Facility%20Condition-Table%201.csv",
stringsAsFactors=FALSE, strip.white=TRUE)[c(1:3)]
helloWorld <- c("H", "e", "l", "l", "o", " ",
"W", "o", "r", "l", "d", "!")
helloFreq <- sort(table(helloWorld),decreasing=T)
seq(helloFreq)
helloFreqName<-names(helloFreq)
makeLeaf <- function(symbol, weight)
list(list(symbol=symbol, weight=weight))
lapply(seq(helloFreq), makeLeaf(i) helloFreqName(x[[i]],helloFreqName[[i]]))
lapply(seq(helloFreq), makeLeaf(i) (helloFreqName[[i]],helloFreqName[[i]]))
lapply(seq(helloFreq), makeLeaf(i)(helloFreqName[[i]],helloFreqName[[i]]))
lapply(seq(helloFreq), function makeLeaf(i)(helloFreqName[[i]],helloFreqName[[i]]))
lapply(seq(helloFreq), function(i) (helloFreqName[[i]],helloFreqName[[i]]))
lapply(seq(helloFreq), function(i) list(helloFreqName[[i]],helloFreqName[[i]]))
lapply(seq(helloFreq), makeLeaf(i) list(helloFreqName[[i]],helloFreqName[[i]]))
lapply(seq(helloFreq), function(i) list(helloFreqName[[i]],helloFreqName[[i]]))
lapply(seq(x), function(i) list(x[[i]],y[[i]]))
lapply(seq(helloFreq), function(i) list(helloFreqName[[i]],helloFreqName[[i]]))
mapply(makeLeaf,list(helloFreqName[[i]],helloFreqName[[i]]))
mapply(makeLeaf(i),list(helloFreqName[[i]],helloFreqName[[i]]))
makeLeaf(list(helloFreqName[[i]],helloFreqName[[i]]))
makeLeaf(helloFreqName, helloFreq)
makeLeaf(helloFreqName[[i]], helloFreq[[i]])
makeLeaf(list(helloFreqName[[i]], helloFreq[[i]]))
helloFreq <- sort(table(helloWorld),decreasing=T)
seq(helloFreq)
makeLeaf(helloFreqName,helloFreq)
helloFreqN<-unname(helloFreq)
makeLeaf(helloFreqName,helloFreqN)
for (i in 1:9) {
makeLeaf(helloFreqName[i],helloFreqN[i])
}
helloLeafList<-list()
for (i in 1:9) {
l<-makeLeaf(helloFreqName[i],helloFreqN[i])
helloLeafList[[name]]<-l
}
helloLeafList<-list()
for (i in 1:9) {
l<-makeLeaf(helloFreqName[i],helloFreqN[i])
helloLeafList<-l
}
helloLeafList<-list()
for (i in 1:9) {
l<-makeLeaf(helloFreqName[i],helloFreqN[i])
helloLeafList[[i]]<-l
}
helloLeafList
helloLeafList<-list()
for (i in 1:9) {
l<-makeLeaf(helloFreqName[i],helloFreqN[i])
helloLeafList[i]<-l
}
helloLeafList
makeCodeTree <- function(left, right)
list(list(left=left,
right=right,
symbol=c(symbol(left), symbol(right)),
weight=weight(left) + weight(right)))
leftBranch <- function(tree) tree[[1]]$left
rightBranch <- function(tree) tree[[1]]$right
chooseBranch <- function(bit, branch) {
if (bit == 0)
leftBranch(branch)
else if (bit == 1)
rightBranch(branch)
else
stop(paste("bad bit in chooseBranch", bit))
}
decode <- function(bits, codeTree) {
result <- list()
n <- length(result)
currentBranch <- codeTree
for (bit in bits) {
currentBranch <- chooseBranch(bit, currentBranch)
if (is.leaf(currentBranch)) {
n <- n + 1
result[[n]] <- symbol(currentBranch)
currentBranch <- codeTree
}
}
## 4c. return a vector of characters
## End of 4c.
}
##
## Given a code, encode the vector of chars
## and return a vector of integers representing bits
##
encode <- function(codeTree, text) {
result <- list()
n <- length(result)
for (ch in text) {
subTree <- codeTree
while (!is.leaf(subTree)) {
n <- n + 1
if (ch %in% symbol(leftBranch(subTree))) {
result[[n]] <- 0
subTree <- leftBranch(subTree)
} else {
result[[n]] <- 1
subTree <- rightBranch(subTree)
}
}
}
## 4c. return a vector of integers
## End of 4c.
}
##
combine <- function(trees) {
insert <- function(item, target) {
if (length(target) == 0) {
item
} else {
##
## 4h. Explain...
## We split the codetrees in tree into two groups,
## ones with weight <= that of item, and those above it.
## The result is a list with *named* elements "FALSE" or "TRUE"
## respectively. In the extreme cases, the list will have one
## element rather than two, all above or all below.
## However, by using the names to access the elements,
## we get an empty list if they don't exist.
## So the code won't fail.
## End of 4h.
x <- local({tmp <- sapply(target, weight); split(seq(target), tmp > weight(item))})
c(target[x[["FALSE"]]], list(item), target[x[["TRUE"]]])
}
}
if (length(trees) < 2)
trees
else {
## Combine the first two
combined <- makeCodeTree(trees[[1]], trees[[2]])
insert(combined, trees[-(1:2)])
}
}
createCodeTree <- function(trees) {
## 4d. Complete the function....
## return a singleton tree
while(length(trees) != 1) {
trees <- combine(trees)
}
trees
## end of 4d.
}
DCPS.Facility<-read.csv("https://raw.githubusercontent.com/codefordc/school-modernization/master/InputData/Facility%20Condition-Table%201.csv",
stringsAsFactors=FALSE, strip.white=TRUE)[c(1:3,5,55,59,68,70)]
colnames(DCPS.Facility)<-c("School.Short","School", "Level","totalSQFT","ProjectType","MajorExp9815","TotalAllotandPlan1621","LifetimeBudget")
View(DCPS.Facility)
b<-read.csv("https://raw.githubusercontent.com/codefordc/school-modernization/master/InputData/Last%20Major%20Construction-Table%201.csv",
stringsAsFactors=FALSE, strip.white=TRUE)[c(2:4)]
is.dataframe(b)
is.data.frame(b)
`%+%` <- function(x, y) {
if (is.data.frame(x)==FALSE | is.data.frame(y)==FALSE)) {
stop ("Data frames only")
`%+%` <- function(x, y) {
if (is.data.frame(x)==FALSE | is.data.frame(y)==FALSE)) {
`%+%` <- function(x, y) {
if (is.data.frame(x)==FALSE | is.data.frame(y)==FALSE) {
stop ("Data frames only")
} else if (sapply(x, is.factor)==TRUE | sapply(y, is.factor)==TRUE) {
stop("Factors are not allowed")
} else if (colnames(x)==colnames(y) & sapply(x, class)==sapply(y, class)) {
rbind(x,y)
} else if (nrow(x)==nrow(y)) {
cbind(x,y)
} else {
warning ("Insufficient match for cbind or rbind")
}
}
b %+% DCPS.Factors
b %+% DCPS.Facility
`%+%` <- function(x, y) {
if (is.data.frame(x)==FALSE | is.data.frame(y)==FALSE) {
stop ("Data frames only")
} else if (sapply(x, is.factor)==TRUE | sapply(y, is.factor)==TRUE) {
stop("Factors are not allowed")
} else if (all(colnames(x)==colnames(y)) & all(sapply(x, class)==sapply(y, class))) {
rbind(x,y)
} else if (nrow(x)==nrow(y)) {
cbind(x,y)
} else {
warning ("Insufficient match for cbind or rbind")
}
}
b %+% DCPS.Facility
`%+%` <- function(x, y) {
if (is.data.frame(x)==FALSE | is.data.frame(y)==FALSE) {
stop ("Data frames only")
} else if any((sapply(x, is.factor)==TRUE)| any(sapply(y, is.factor)==TRUE)) {
stop("Factors are not allowed")
} else if (all(colnames(x)==colnames(y)) & all(sapply(x, class)==sapply(y, class))) {
`%+%` <- function(x, y) {
if (is.data.frame(x)==FALSE | is.data.frame(y)==FALSE) {
stop ("Data frames only")
} else if any((sapply(x, is.factor)==TRUE)| any(sapply(y, is.factor)==TRUE)) {
`%+%` <- function(x, y) {
if (is.data.frame(x)==FALSE | is.data.frame(y)==FALSE) {
stop ("Data frames only")
} else if (any((sapply(x, is.factor)==TRUE)| any(sapply(y, is.factor)==TRUE))) {
stop("Factors are not allowed")
} else if (all(colnames(x)==colnames(y)) & all(sapply(x, class)==sapply(y, class))) {
rbind(x,y)
} else if (nrow(x)==nrow(y)) {
cbind(x,y)
} else {
warning ("Insufficient match for cbind or rbind")
}
}
b %+% DCPS.Facility
colnames(b)
colnames(b)==colnames(DCPS.Facility)
a<-read.csv("https://raw.githubusercontent.com/codefordc/school-modernization/master/InputData/Last%20Major%20Construction-Table%201.csv",
stringsAsFactors=FALSE, strip.white=TRUE)[c(2:4)]
a %+% b
c<-a %+% b
colnames(b)<-c("a1","b2","c3")
`%+%` <- function(x, y) {
if (is.data.frame(x)==FALSE | is.data.frame(y)==FALSE) {
stop ("Data frames only")
} else if (any((sapply(x, is.factor)==TRUE)| any(sapply(y, is.factor)==TRUE))) {
stop("Factors are not allowed")
} else if (all(colnames(x)==colnames(y)) & all(sapply(x, class)==sapply(y, class))) {
rbind(x,y)
} else if (nrow(x)==nrow(y)) {
cbind(x,y)
} else {
warning ("Insufficient match for cbind or rbind")
}
}
c<-a %+% b
d<-head(b,100)
c<-a %+% d
library(acs)
DCZip<-geo.make(zip.code=c(20032,20020,20019,20024,20001,20002,20003,20018,20017,20011,20010,20012,20015,
20016,20007,20008,20009,20005,20036,20037))
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number="B07002", col.names="pretty")
library(acs)
DCZip<-geo.make(zip.code=c(20032,20020,20019,20024,20001,20002,20003,20018,20017,20011,20010,20012,20015,
20016,20007,20008,20009,20005,20036,20037))
fetchACS<-function(x,y) {
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number=x, col.names="pretty")
as.data.frame(cbind(y@geography,
y@estimate,
y@standard.error))
}
ageEst<-fetchACS("B07002",dcAge)
marEst<-fetchACS("B07008",dcMarry)
edEst<-fetchACS("B07009",dcEd)
incomeEst<-fetchACS("B07011",dcIncome)
incomeEst<-fetchACS("B07011",dcIncome)
tenEst<-fetchACS("B07013",dcTen)
incomeEst<-fetchACS("B07011",dcIncome)
View(ageEst)
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number="B07002", col.names="pretty")
y@stanfard.error
y@standard.error
View(ageEst)
ya<-cbind(y@estimate,y@standard.error)
View(ya)
ya<-cbind(y@standard.error, y@estimate)
View(ya)
SE<-y@standard.error
Est<-y@estimate
YA<-cbind(SE,Est)
View(YA)
SE<-as.data.frame(y@standard.error)
Est<-as.data.frame(y@estimate)
YA<-cbind(SE,Est)
View(YA)
View(SE)
View(Est)
incomeEst<-fetchACS("B07011",dcIncome)
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number="B07011", col.names="pretty")
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number="B07011", col.names="pretty")
DCZip<-geo.make(zip.code=c(20032,20020,20019,20024,20001,20002,20003,20018,20017,20011,20010,20012,20015,
20016,20007,20008,20009,20005,20036,20037))
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number="B07011", col.names="pretty")
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number="B07011", col.names="pretty")
fetchACS<-function(x,y) {
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number=x, col.names="pretty")
as.data.frame(cbind(y@geography,
y@estimate,
y@standard.error))
}
ageEst<-fetchACS("B07002",dcAge)
marEst<-fetchACS("B07008",dcMarry)
edEst<-fetchACS("B07009",dcEd)
tenEst<-fetchACS("B07013",dcTen)
subsetCol<-function (Z) {
Z[grep('Total:|different state|zipcodetabulationarea',colnames(Z))]
}
marEst2<-subsetCol(marEst)
ageEst2<-subsetCol(ageEst)
edEst2<-subsetCol(edEst)
tenEst2<-subsetCol(tenEst)
colnames(tenEst2)<-c("zip","total","totalmove","owner","renter","totalSE","totalmoveSE","ownerSE","renterSE")
attach(tenEst2)
tenEst2$renterSPer<-renterSE/renter
tenEst2$renterPer<-renter/totalmove
colnames(marEst2)<-c("zip","total","totalmove", "neverMarried","married","divorced","separated","widowed",
"totalSE","totalmoveSE", "neverMarriedSE","marriedSE","divorcedSE","separatedSE","widowedSE")
attach(marEst2)
marEst2$nmSPer<-neverMarriedSE/neverMarried
marEst2$nmPer<-neverMarried/totalmove
colnames(edEst2)<-c("zip","total","totalmove","ltHS","HS","someCol","Bac","Grad",
"totalSE","totalmoveSE","ltHSSE","HSSE","someColSE","BacSE","GradSE")
attach(edEst2)
edEst2$bacSPer<-BacSE/Bac
edEst2$gradSPer<-GradSE/Grad
View(ageEst2)
View(edEst2)
View(marEst2)
View(tenEst2)
(16239+4806)/(15440+30982)
31871/51015
library(acs)
DCZip<-geo.make(zip.code=c(20032,20020,20019,20024,20001,20002,20003,20018,20017,20011,20010,20012,20015,
20016,20007,20008,20009,20005,20036,20037))
fetchACS<-function(x,y) {
y<-acs.fetch(endyear=2014,span=5,geography=DCZip,
table.number=x, col.names="pretty")
as.data.frame(cbind(y@geography,
y@estimate,
y@standard.error))
}
marEst<-fetchACS("B07008",dcMarry)
subsetCol<-function (Z) {
Z[grep('Total:|different state|zipcodetabulationarea',colnames(Z))]
}
marEst2<-subsetCol(marEst)
View(marEst2)
colnames(marEst2)<-c("zip","total","totalmove", "neverMarried","married","divorced","separated","widowed",
"totalSE","totalmoveSE", "neverMarriedSE","marriedSE","divorcedSE","separatedSE","widowedSE")
attach(marEst2)
marEst2$nmSPer<-neverMarriedSE/neverMarried
marEst2$nmPer<-neverMarried/totalmove
View(marEst2)
marEst2$nmUp<-(neverMarriedSE+neverMarried)/neverMarried
marEst2$nmLow<-(neverMarried-neverMarriedSE)/neverMarried
marEst2$nmPer<-neverMarried/totalmove
View(marEst)
View(marEst2)
marEst2$nmUp<-(neverMarriedSE+neverMarried)/totalmove
marEst2$nmLow<-(neverMarried-neverMarriedSE)/totalmove
View(marEst2)
CityFip<-geo.make(fips_code=c(11001,04013,06075,06037,06073,06085))
CityFip<-geo.make(county=c(11001,04013,06075,06037,06073,06085))
CityFip<-geo.make(state=c(11,04,06,06,06,06),county=c(001,013,075,037,073,085))
fetchACS<-function(x,y) {
y<-acs.fetch(endyear=2014,span=5,geography=CityFip,
table.number=x, col.names="pretty")
as.data.frame(cbind(y@geography,
y@estimate,
y@standard.error))
}
marEst<-fetchACS("B07008",dcMarry)
subsetCol<-function (Z) {
Z[grep('Total:|different state|zipcodetabulationarea',colnames(Z))]
}
marEst2<-subsetCol(marEst)
colnames(marEst2)<-c("zip","total","totalmove", "neverMarried","married","divorced","separated","widowed",
"totalSE","totalmoveSE", "neverMarriedSE","marriedSE","divorcedSE","separatedSE","widowedSE")
View(marEst)
View(marEst2)
colnames(marEst2)<-c("total","totalmove", "neverMarried","married","divorced","separated","widowed",
"totalSE","totalmoveSE", "neverMarriedSE","marriedSE","divorcedSE","separatedSE","widowedSE")
attach(marEst2)
View(marEst2)
marEst2$nmSPer<-neverMarriedSE/neverMarried
marEst2$nmUp<-(neverMarriedSE+neverMarried)/totalmove
marEst2$nmLow<-(neverMarried-neverMarriedSE)/totalmove
marEst2$nmPer<-neverMarried/totalmove
View(marEst)
View(marEst2)
marEst2$nmPer<-1-(married/totalmove)
View(marEst2)
ageEst<-fetchACS("B07002",dcAge)
View(ageEst)
setwd("/Users/katerabinowitz/Documents/DataLensDC/Construction_DC")
library(rgdal)
library(splitstackshape)
library(plyr)
library(ggmap)
Build1216<-read.csv("NewConstruction1216.csv", stringsAsFactors=FALSE, strip.white=TRUE)
BD<-as.data.frame(unique(Build1216$FULL_ADDRESS[duplicated(Build1216$FULL_ADDRESS)]))
colnames(BD)<-c("FULL_ADDRESS")
BuildDup<-merge(BD, Build1216, by=c("FULL_ADDRESS"),type="left")
BuildDup<-BuildDup[order(BuildDup$FULL_ADDRESS,BuildDup$ISSUE_DATE),]
BD2 <- data.table(BuildDup, key = c('FULL_ADDRESS'))
BD<-BD2[unique(BD2[,key(BD2), with = FALSE]), mult = 'first']
DupAddress<-subset(BuildDup,!(BuildDup$PERMIT_ID %in% BD$PERMIT_ID))
Build1216<-subset(Build1216,!(Build1216$PERMIT_ID %in% DupAddress$PERMIT_ID))
#Permits that revise that address should have the original permit removed in order to align with the correct address
Revision<-subset(Build1216,grepl("REVISION|CORRECT ADDRESS",Build1216$DESC_OF_WORK))
Build1216<-subset(Build1216,!(Build1216$PERMIT_ID %in% c("B1140521","B1202952","B1209223","B1300655","B1201080",
"B1002258","B1201235","B1201241","B1201247","B1201249","B1201251")))
Original<-subset(Build1216,(Build1216$PERMIT_ID %in% c("B1140521","B1202952","B1209223","B1300655","B1201080",
"B1002258","B1201235","B1201241","B1201247","B1201249","B1201251")))
rm(BD,BD2,BuildDup,DupAddress,Revision)
Build1216$PropType<-ifelse(grepl("SINGLE FAM|SFD|S.F DWELLING|SINGLE-FAMILY|S.F.D|SIGLE FAMILY|ONE FAMILY|SFH",
Build1216$DESC_OF_WORK),"Single Family",
ifelse(grepl("APARTMENT|UNIT|TWO FAMILY|TWO-FAMILY|2 FAMILY|2 FAMILLY|MIXED USE|MIXED-USE|FLAT",Build1216$DESC_OF_WORK)
| grepl("CONDO|MULTI USE|9 STORY RESIDENTIAL BUILDING|DUPLEX|MULTI-FAMILY|MULTIFAMILY",Build1216$DESC_OF_WORK)
| grepl("9-STORY BUILDING FOR FOREIGN|FIVE STORY RESIDENTIAL|NEW 3 STORY BUILDING WITH A ROOF DECK",
Build1216$DESC_OF_WORK),"Multi Family",
ifelse(grepl("TOWNHOUSE|TOWNHOME|NEW HOUSE|BEDROOM HOUSE|3 STORY HOUSE|STORY HOUSE|TOWN HOME",Build1216$DESC_OF_WORK)
|grepl("TOWN HOUSE|SEMI DETACHED DWELLING|ROW HOME|HOME|STORY SEMI DETATCHED HOUSE",
Build1216$DESC_OF_WORK),"Single Family",NA)))
Build1216$PropType<-ifelse(Build1216$FULL_ADDRESS %in% c("720 JEFFERSON ST NW","410 EASTERN AVE NE","426 EASTERN AVE NE",
"442 EASTERN AVE NE","444 EASTERN AVE NE","446 EASTERN AVE NE",
"448 EASTERN AVE NE","450 EASTERN AVE NE"),
"Single Family",Build1216$PropType)
table(Build1216$PropType)
#Check undefined properties for any leftover residential
NABuild<-subset(Build1216,is.na(Build1216$PropType))
#Check Single Family for mismatches
SFD<-subset(Build1216,Build1216$PropType=="Single Family")
SFD<-SFD[order(SFD$FULL_ADDRESS),]
SFD<-subset(SFD,!grepl("WOOD PERGOLA|ELEVATOR ONLY|EXISTING POOLHOUSE|2013 SOLAR DEC|5TH YOUTH RESIDENTIAL",
SFD$DESC_OF_WORK))
SFD$PropType<-ifelse(grepl("2 UNIT BUILDING|10-UNIT APARTMENT BUILDING|MIXED USE",SFD$DESC_OF_WORK),
"Multi Family",SFD$PropType)
#Check Multi Family for mismatches
Multi<-subset(Build1216,Build1216$PropType=="Multi Family")
Multi<-subset(Multi,!(grepl("MEDICAL CLINIC|CT MOBILE UNIT|HOTEL|BASEBALL DUGOUTS",Multi$DESC_OF_WORK)
| grepl("COMMUNITY USE|TEMPORARY ENGINE COMPANY 14|PROPERTY MANAGEMENT AND COMMUNITY BUILDING",Multi$DESC_OF_WORK)
| grepl("COMMUNITY CENTER|HAROLD J. GORDON|SELF STORAGE FACILITY|15 HIGH PRIVATE GARAGE",Multi$DESC_OF_WORK)
| grepl("11 STORY MIXED USE BUILDING, RETAIL AND OFFICE WITH UNDERGROUND PARKING.",Multi$DESC_OF_WORK)))
Multi<-subset(Multi, !(Multi$FULL_ADDRESS %in% c("1728 14TH ST NW", "800 22ND ST NW", "2700 MARTIN LUTHER KING JR AVE SE",
"5220 WISCONSIN AVE NW")))
Multi$PropType<-ifelse(grepl("ATTACHED TOWN HOME THAT IS PART OF A 20 UNIT|SIDE ELEVATION END UNIT OPTIONS|SIDE BY SIDE",
Multi$DESC_OF_WORK),"Single Family",Multi$PropType)
#Combine for accurate single/multi family
ResBuilding<-rbind(SFD,Multi)
#Differentiate between 2 unit and 2+unit multi family
Multi<-subset(ResBuilding,ResBuilding$PropType=="Multi Family")
Multi$PropType<-ifelse(grepl(" 2 UNIT|TWO UNIT|TWO-UNIT|TWO FAMILY| 2 FAMILLY|TWO-FAMILY| 2 FAMILY| 2-UNIT|DUPLEX|TWO (2) UNIT|(2 UNITS)|2 NEW DWELLING UNIT|2 DWELLING UNIT",
Multi$DESC_OF_WORK),"Multi-Two Unit",Multi$PropType)
Multi$PropType<-ifelse(Multi$FULL_ADDRESS %in% c("1400 K ST SE","1402 K ST SE","1404 K ST SE"), "Multi-Two Unit",
ifelse(Multi$FULL_ADDRESS %in% c("1341 IRVING ST NW"),"Multi Family",Multi$PropType))
#All residential builds since 2012 differentiating b/w SFD, duplex and multi
ResBuilding<-rbind(SFD,Multi)
NullIsland<-subset(ResBuilding, ResBuilding$LATITUDE==0.00000)
neverNull<-subset(ResBuilding, ResBuilding$LATITUDE!=0.00000)
Null<-paste(NullIsland$FULL_ADDRESS," Washington, DC",sep="")
Address<-geocode(Null, source=c("google"))
noMoreNull<-cbind(NullIsland,Address)[-c(20:21)]
colnames(noMoreNull)[c(38:39)]<-c("LONGITUDE","LATITUDE")
ResBuildingOut<-rbind(neverNull,noMoreNull)
ResBuildingOut<-subset(ResBuildingOut, abs(ResBuildingOut$LONGITUDE)<80)
write.csv(ResBuildingOut,"ResBuild.csv",row.names=FALSE)
GeoFlip<-GeoFlip[c(2:3)]
addAll<-SpatialPoints(GeoFlip, proj4string=CRS(as.character("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")))
HoodID <- over(addAll, map )
clusterMap = readOGR("http://opendata.dc.gov/datasets/f6c703ebe2534fc3800609a07bad8f5b_17.geojson", "OGRGeoJSON")
ResLL<-ResBuildingOut[c(21,20)]
addAll<-SpatialPoints(ResLL, proj4string=CRS(as.character("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")))
HoodID <- over(addAll, clusterMap )
ResBuildHood<-cbind(ResBuildingOut,HoodID)
View(ResBuildingOut)
ResBuildingOut<-subset(ResBuildingOut, abs(ResBuildingOut$LONGITUDE)<80)[c(3,20,21,39)]
View(ResBuildingOut)
write.csv(ResBuildingOut,"ResBuild.csv",row.names=FALSE)
